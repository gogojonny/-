练习的点：

* random的使用
* 球处理逻辑（球的构造，球的动画）
* mouseover事件



补充的指示点：

* canvas的基本使用
* window对象的宽度和高度
* requestAnimationFrame在动画中的使用



### canvas的基本使用

使用document.getEBTN获取canvas元素

使用canvas对象的getContext获取渲染画布，或者为null

在同一个canvas对象上多次调用并传入同一参数，返回的结果都是第一次调用时返回的渲染画布实例，也就是说一个canvas元素调用同一个参数时只会返回相同的对象。

getContex接收两个参数，第一个参数表示画布的类型：

* 2d， 表示一个2d画布
* webgl： 表示一个webgl画布（3d）
* webgl2：也表示一个webgl画布
* bitmaprenderer：不是太懂

contextAttributes，这是一个可选参数，用于当渲染画布时设置几个属性，和渲染模式有关





### window.innerWidth   window,innerheight

这个表示当前显示页面的宽度和高度，包括垂直滚动条



### math.ceil

总会返回比当前参数大或等于当前参数的最小整数



### canvas.width   canvas.height

表示当前canvas画布的宽度和高度



### CanvasRenderingContext2D.beginPath()

调用这个方法代表你的2d画布想要开辟一条路径

 

### CanvasRenderingContext2D.arc()

调用这个方法表示当前2d画布想要创建一个弧形路径

```javascript
c.arc(this.x, this.y, this.radius, 0, 2 * Math.PI);
```

前两个参数代表弧形路径的圆心，第三个参数表示半径，第四个和第五个参数表示弧度，这里表示0到2π，也就是整个圆



### CanvasRenderingContext2D.fillStyle

这个属性一般表示在2d画布中添加颜色



### CanvasRenderingContext2D.fill()

这个属性用于将当前已经完成的路径添加之前设置的style，是和fillstyle合用的



### CanvasRenderingContext2D.clearRect()

这个是一个刷屏方法，可以将以前上画布内的东西刷没



### window.requestAnimationFrame()

这个方法表示想高速浏览器你希望渲染一段动画并请求浏览器在下一次重绘之前调用具体的函数来更新动画。这个具体的函数被当做参数调用在这个方法中



```
注意： 如果你想在下一次重绘之前播放下一帧动画那么你的回调函数必须自己调用requestAnimationFrame方法。另外，调用一次requestAnimationFrame表示执行一帧
```

requestAnimationFrame主要目的是播放动画的，调用一次表示一帧，回调函数会告诉浏览器这一帧动画长什么样，由于是回调函数，所以不会影响回调函数内部其他代码的执行，另外，想连续播放动画就需要在回调函数内调用这个方法



### 圆的绘画逻辑

首先，这次画出圆是用到了canvas。那么想画一个圆就需要把圆心，半径，颜色的信息传给canvas绘画者。考虑一个圆，圆有圆心，有半径，有颜色，圆可以被创造，可以移动（动画），因为圆可以移动，所以圆有偏移量。

因此可以构造一个圆类，包含圆心，半径，偏移量和圆的构造器

半径要考虑最大半径与最小半径

圆心要考虑圆不能出边框

偏移量要考虑出现方向相反的情况



![image-20230128202427106](C:\Users\35392\AppData\Roaming\Typora\typora-user-images\image-20230128202427106.png)



### 圆的动画逻辑

想让一个圆动起来，实际上是很多个静态圆在不同位置随时间的播放。

所以想做圆的动画就要考虑圆的每一帧

圆可以向上，向下，向左和向右进行移动，因此偏移量必须是可以正，也可以是负。另外圆的移动不是一个随机过程，而是有一个重力过程，所以建议生成的圆一开始向下的偏移量是正，当遇到墙壁时，圆会被弹开，这时的需要判断何时是弹开的状态，被弹开后很明显方向就会改变，因此一旦触发弹开那么偏移量的方向就会发生改变。还是因为重力效果，所以每次数值方向弹开都不会回到原来的高度。水平方向不需要考虑重力，所以偏移量直接去负就可以



如果考虑齐全那么按照上面的方法就是一帧了，这一帧结束后还要有下一帧，所以要把动画逻辑作为回调函数传入requestAnimationFrame中，并自己调用这个方法来达到循环引用产生不间断的动画的目的



实际上不会只有一个圆，而是会有很多圆，每个圆的实例都会保留自己下一帧的位置，因此在定义下一帧动画时，需要给每一个圆对象都进行一次刷新。



### 鼠标覆盖事件

当鼠标在圆上的时候，圆会变大，逻辑是判断当前鼠标位置是否满足条件，如果满足条件，圆的半径在下一帧就会增大，但是增大会有最大值，不会一直增大，圆与鼠标覆盖的判断条件就是当前鼠标坐标在圆的范围内，当鼠标脱离圆的范围时，圆还是会恢复到最初的半径（需要保留最初的半径）



还有一个圆的动态添加和删除，每个400ms就会对数组上的圆实例进行添加和删除

