<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>

<body>
  <script>
    // 生成器函数返回的生成器可以调用next方法,这个生成器是一个特殊的迭代器,所以生成器调用next方法也会有返回值
    //    1.返回值也是{done:false,value:undefine}的形式,value值是由yield后面的内容决定
    //    2.生成器的next方法可以传入参数,这是与迭代器很大的区别,传入的参数需要在yield前面定义形参,用形参来接收,且因为第一次调用时不可能使用yield,所以第一次调用next方法不能传入参数,如果必须传入参数,就需要在调用生成器函数的时候传入
    //    3.yield可以看做一个特殊的return,yield后面的是调用next方法的返回值的一部分,前面就比较特殊,定义形参用于接收next传入的参数.  另外如果生成器函数是因为yield而暂停的,那么返回的done为false,否则为true

    // 生成器函数function后面加*
    // function* foo() {
    //   console.log('生成器内部代码', 111);
    //   console.log('生成器内部代码', 222);
    //   yield 'aaa'
    //   console.log('生成器内部代码', 333);
    //   console.log('生成器内部代码', 444);
    //   yield 'bbb'
    //   console.log('生成器内部代码', 555);
    //   console.log('生成器内部代码', 666);
    //   return 'ccc'
    // }
    // // 利用生成器函数生成生成器
    // let generator = foo()
    // console.log(generator.next());
    // console.log(generator.next());
    // console.log(generator.next());

    // 生成器函数function前加*
    function* bar(first) {
      console.log('生成器内部代码', 111, first);
      console.log('生成器内部代码', 222, first);
      // 在yield前定义形参用于接收next传入的参数,接收第二次传入的参数,返回第一次调用的值
      let a = yield 'aaa'
      console.log('生成器内部代码', 333, a);
      console.log('生成器内部代码', 444, a);
      let name2 = yield 'bbb'
      console.log('生成器内部代码', 555, name2);
      console.log('生成器内部代码', 666, name2);
      return 'ccc'
    }

    let generator2 = bar('第一次传入的参数')
    // 第一次调用next没法传入参数,因为没有形参可以接收参数
    console.log(generator2.next());
    console.log(generator2.next('a'));
    console.log(generator2.next('name2'));




  </script>

</body>

</html>